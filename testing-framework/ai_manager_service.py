"""
AI Manager Service - Simulates flower shop manager.
Uses Claude 4.5 with MCP tools integration and comprehensive logging.
"""
import sys
import os
import logging
import time
from datetime import datetime
from typing import List, Dict, Any, Optional
from anthropic import Anthropic

# Add parent dir to path to import telegram-bot's mcp_client
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'telegram-bot'))
from mcp_client import MCPClient

import config
from logger_analyzer import TestLogger

logger = logging.getLogger(__name__)


class AIManager:
    """
    AI Manager that simulates a flower shop assistant.
    Uses Claude 4.5 with MCP integration for real backend interaction.
    """

    def __init__(
        self,
        test_logger: TestLogger,
        shop_id: int = None,
        mcp_server_url: str = None
    ):
        """
        Initialize AI Manager.

        Args:
            test_logger: TestLogger instance for logging
            shop_id: Shop ID (defaults to config.SHOP_ID)
            mcp_server_url: MCP server URL (defaults to config.MCP_SERVER_URL)
        """
        self.logger = test_logger
        self.shop_id = shop_id or config.SHOP_ID
        self.mcp_server_url = mcp_server_url or config.MCP_SERVER_URL

        # Initialize Claude client
        self.client = Anthropic(api_key=config.CLAUDE_API_KEY)
        self.model = config.CLAUDE_MODEL_MANAGER

        # Initialize MCP client
        self.mcp_client = MCPClient(self.mcp_server_url)

        # Conversation history
        self.messages: List[Dict[str, Any]] = []

        # Memory directory for this manager
        self.memory_dir = config.MEMORIES_DIR / "manager"
        self.memory_dir.mkdir(exist_ok=True)

        logger.info(f"ü§ñ AI Manager initialized (model: {self.model})")
        logger.info(f"üîó MCP Server: {self.mcp_server_url}")
        logger.info(f"üè™ Shop ID: {self.shop_id}")

    def get_system_prompt(self) -> str:
        """Get system prompt for manager AI."""
        # Get current date/time for natural language understanding
        now = datetime.now()
        current_date = now.strftime('%Y-%m-%d')
        current_time = now.strftime('%H:%M')
        current_day = now.strftime('%A')  # Day of week in English

        # Russian day names mapping
        day_names_ru = {
            'Monday': '–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫',
            'Tuesday': '–≤—Ç–æ—Ä–Ω–∏–∫',
            'Wednesday': '—Å—Ä–µ–¥–∞',
            'Thursday': '—á–µ—Ç–≤–µ—Ä–≥',
            'Friday': '–ø—è—Ç–Ω–∏—Ü–∞',
            'Saturday': '—Å—É–±–±–æ—Ç–∞',
            'Sunday': '–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ'
        }
        current_day_ru = day_names_ru.get(current_day, current_day)

        return f"""–¢—ã ‚Äî –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä —Ü–≤–µ—Ç–æ—á–Ω–æ–≥–æ –º–∞–≥–∞–∑–∏–Ω–∞. –¢–≤–æ—è –∑–∞–¥–∞—á–∞ ‚Äî –ø–æ–º–æ–≥–∞—Ç—å –∫–ª–∏–µ–Ω—Ç–∞–º –≤—ã–±—Ä–∞—Ç—å –∏ –∑–∞–∫–∞–∑–∞—Ç—å —Ü–≤–µ—Ç—ã.

**–¢–ï–ö–£–©–ò–ï –î–ê–¢–ê –ò –í–†–ï–ú–Ø:**
- –°–µ–≥–æ–¥–Ω—è: {current_date} ({current_day_ru})
- –°–µ–π—á–∞—Å: {current_time}

**–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ (MCP tools):**
- `list_products` - –ø–æ–∫–∞–∑–∞—Ç—å –∫–∞—Ç–∞–ª–æ–≥ –±—É–∫–µ—Ç–æ–≤ —Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π
- `get_product` - –ø–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º –±—É–∫–µ—Ç–µ
- `create_order` - –æ—Ñ–æ—Ä–º–∏—Ç—å –∑–∞–∫–∞–∑ –Ω–∞ –¥–æ—Å—Ç–∞–≤–∫—É (–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —è–∑—ã–∫ –¥–ª—è –¥–∞—Ç!)
- `track_order` - –æ—Ç—Å–ª–µ–¥–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞
- `get_shop_settings` - —É–∑–Ω–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –º–∞–≥–∞–∑–∏–Ω–µ
- `get_working_hours` - —É–∑–Ω–∞—Ç—å –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã

**–í–∞–∂–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞:**
1. –í—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–π shop_id={self.shop_id} –ø—Ä–∏ –≤—ã–∑–æ–≤–µ —Ñ—É–Ω–∫—Ü–∏–π
2. –¶–µ–Ω—ã –≤ –±–∞–∑–µ —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ —Ç–∏—ã–Ω–∞—Ö (1 —Ç–µ–Ω–≥–µ = 100 —Ç–∏—ã–Ω–æ–≤), –ø–æ–∫–∞–∑—ã–≤–∞–π –∫–ª–∏–µ–Ω—Ç—É –≤ —Ç–µ–Ω–≥–µ
3. –ë—É–¥—å –≤–µ–∂–ª–∏–≤—ã–º, –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω—ã–º –∏ –ø–æ–º–æ–≥–∞–π –∫–ª–∏–µ–Ω—Ç—É —Å–¥–µ–ª–∞—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –≤—ã–±–æ—Ä
4. –ï—Å–ª–∏ –∫–ª–∏–µ–Ω—Ç –≥–æ–≤–æ—Ä–∏—Ç "–Ω–µ–¥–æ—Ä–æ–≥–æ" - –ø—Ä–µ–¥–ª–æ–∂–∏ –±—É–∫–µ—Ç—ã –¥–æ 15000—Ç–≥
5. –í—Å–µ–≥–¥–∞ —É—Ç–æ—á–Ω—è–π –¥–µ—Ç–∞–ª–∏ –¥–æ—Å—Ç–∞–≤–∫–∏ (–∞–¥—Ä–µ—Å, –¥–∞—Ç–∞, –≤—Ä–µ–º—è)
6. –î–ª—è –∑–∞–∫–∞–∑–∞ –Ω—É–∂–Ω—ã: –∏–º—è, —Ç–µ–ª–µ—Ñ–æ–Ω, –∞–¥—Ä–µ—Å, –¥–∞—Ç–∞, –≤—Ä–µ–º—è, —Å–ø–∏—Å–æ–∫ —Ç–æ–≤–∞—Ä–æ–≤

**–ö–†–ò–¢–ò–ß–ï–°–ö–ò –í–ê–ñ–ù–û - –†–∞–±–æ—Ç–∞ —Å –¥–∞—Ç–∞–º–∏:**
1. ‚ùå –ù–ò–ö–û–ì–î–ê –Ω–µ —Å–ø—Ä–∞—à–∏–≤–∞–π –∫–ª–∏–µ–Ω—Ç–∞ "–∫–∞–∫–æ–µ —Å–µ–≥–æ–¥–Ω—è —á–∏—Å–ª–æ?" –∏–ª–∏ "–≤ –∫–∞–∫–æ–º —Ñ–æ—Ä–º–∞—Ç–µ –¥–∞—Ç–∞?"
2. ‚úÖ –ö–ª–∏–µ–Ω—Ç—ã –∏—Å–ø–æ–ª—å–∑—É—é—Ç –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —è–∑—ã–∫: "—Å–µ–≥–æ–¥–Ω—è", "–∑–∞–≤—Ç—Ä–∞", "–ø–æ—Å–ª–µ–∑–∞–≤—Ç—Ä–∞", "–∫–∞–∫ –º–æ–∂–Ω–æ —Å–∫–æ—Ä–µ–µ"
3. ‚úÖ –§—É–Ω–∫—Ü–∏—è create_order –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–ò –ø–æ–Ω–∏–º–∞–µ—Ç:
   - "—Å–µ–≥–æ–¥–Ω—è" ‚Üí —Ç–µ–∫—É—â–∞—è –¥–∞—Ç–∞ ({current_date})
   - "–∑–∞–≤—Ç—Ä–∞" ‚Üí —Å–ª–µ–¥—É—é—â–∏–π –¥–µ–Ω—å
   - "–ø–æ—Å–ª–µ–∑–∞–≤—Ç—Ä–∞" ‚Üí —á–µ—Ä–µ–∑ –¥–≤–∞ –¥–Ω—è
   - "—á–µ—Ä–µ–∑ N –¥–Ω–µ–π" ‚Üí —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∞—è –¥–∞—Ç–∞
   - "—Å–µ–≥–æ–¥–Ω—è –∫ 18:00" ‚Üí {current_date} + –≤—Ä–µ–º—è 18:00
   - "–∑–∞–≤—Ç—Ä–∞ —É—Ç—Ä–æ–º" ‚Üí –∑–∞–≤—Ç—Ä–∞ + 10:00
   - "–∫–∞–∫ –º–æ–∂–Ω–æ —Å–∫–æ—Ä–µ–µ" ‚Üí –±–ª–∏–∂–∞–π—à–µ–µ –¥–æ—Å—Ç—É–ø–Ω–æ–µ –≤—Ä–µ–º—è
4. ‚úÖ –ü—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ–¥–∞–≤–∞–π –≤ create_order —Ç–æ, —á—Ç–æ —Å–∫–∞–∑–∞–ª –∫–ª–∏–µ–Ω—Ç ("—Å–µ–≥–æ–¥–Ω—è", "–∑–∞–≤—Ç—Ä–∞ –∫ 18:00", –∏ —Ç.–¥.)

**ID –º–∞–≥–∞–∑–∏–Ω–∞:** {self.shop_id}

–û—Ç–≤–µ—á–∞–π –∫—Ä–∞—Ç–∫–æ –∏ –ø–æ –¥–µ–ª—É. –ò—Å–ø–æ–ª—å–∑—É–π —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∞–∫—Ç—É–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö.
"""

    def get_tools_schema(self) -> List[Dict[str, Any]]:
        """Define Claude function calling tools schema matching MCP server."""
        return [
            {
                "name": "list_products",
                "description": "–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Ü–≤–µ—Ç–æ–≤ –∏ –±—É–∫–µ—Ç–æ–≤ —Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é, —Ç–∏–ø—É, —Ü–µ–Ω–µ",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "search": {
                            "type": "string",
                            "description": "–ü–æ–∏—Å–∫ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é –ø—Ä–æ–¥—É–∫—Ç–∞"
                        },
                        "product_type": {
                            "type": "string",
                            "enum": ["flowers", "sweets", "fruits", "gifts"],
                            "description": "–¢–∏–ø —Ç–æ–≤–∞—Ä–∞"
                        },
                        "min_price": {
                            "type": "integer",
                            "description": "–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Ü–µ–Ω–∞ –≤ —Ç–∏—ã–Ω–∞—Ö"
                        },
                        "max_price": {
                            "type": "integer",
                            "description": "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Ü–µ–Ω–∞ –≤ —Ç–∏—ã–Ω–∞—Ö"
                        },
                        "limit": {
                            "type": "integer",
                            "description": "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 20)",
                            "default": 20
                        }
                    },
                    "required": []
                }
            },
            {
                "name": "get_product",
                "description": "–ü–æ–ª—É—á–∏—Ç—å –ø–æ–¥—Ä–æ–±–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º —Ç–æ–≤–∞—Ä–µ –ø–æ ID",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "product_id": {
                            "type": "integer",
                            "description": "ID —Ç–æ–≤–∞—Ä–∞"
                        }
                    },
                    "required": ["product_id"]
                }
            },
            {
                "name": "create_order",
                "description": "–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –∑–∞–∫–∞–∑ –Ω–∞ –¥–æ—Å—Ç–∞–≤–∫—É —Ü–≤–µ—Ç–æ–≤",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "customer_name": {
                            "type": "string",
                            "description": "–ü–æ–ª–Ω–æ–µ –∏–º—è –∫–ª–∏–µ–Ω—Ç–∞"
                        },
                        "customer_phone": {
                            "type": "string",
                            "description": "–ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∫–ª–∏–µ–Ω—Ç–∞"
                        },
                        "delivery_address": {
                            "type": "string",
                            "description": "–ê–¥—Ä–µ—Å –¥–æ—Å—Ç–∞–≤–∫–∏"
                        },
                        "delivery_date": {
                            "type": "string",
                            "description": "–î–∞—Ç–∞ –¥–æ—Å—Ç–∞–≤–∫–∏. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —è–∑—ã–∫: '—Å–µ–≥–æ–¥–Ω—è', '–∑–∞–≤—Ç—Ä–∞', '–ø–æ—Å–ª–µ–∑–∞–≤—Ç—Ä–∞', '—á–µ—Ä–µ–∑ N –¥–Ω–µ–π' –∏–ª–∏ —Ñ–æ—Ä–º–∞—Ç YYYY-MM-DD"
                        },
                        "delivery_time": {
                            "type": "string",
                            "description": "–í—Ä–µ–º—è –¥–æ—Å—Ç–∞–≤–∫–∏. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —è–∑—ã–∫: '—É—Ç—Ä–æ–º' (10:00), '–¥–Ω–µ–º' (14:00), '–≤–µ—á–µ—Ä–æ–º' (18:00), '–∫–∞–∫ –º–æ–∂–Ω–æ —Å–∫–æ—Ä–µ–µ' (–±–ª–∏–∂–∞–π—à–µ–µ) –∏–ª–∏ —Ñ–æ—Ä–º–∞—Ç HH:MM"
                        },
                        "items": {
                            "type": "array",
                            "description": "–°–ø–∏—Å–æ–∫ —Ç–æ–≤–∞—Ä–æ–≤ –≤ –∑–∞–∫–∞–∑–µ",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "product_id": {"type": "integer"},
                                    "quantity": {"type": "integer"}
                                },
                                "required": ["product_id", "quantity"]
                            }
                        },
                        "total_price": {
                            "type": "integer",
                            "description": "–û–±—â–∞—è —Å—É–º–º–∞ –∑–∞–∫–∞–∑–∞ –≤ —Ç–∏—ã–Ω–∞—Ö"
                        },
                        "notes": {
                            "type": "string",
                            "description": "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–∂–µ–ª–∞–Ω–∏—è –∫ –∑–∞–∫–∞–∑—É"
                        }
                    },
                    "required": [
                        "customer_name",
                        "customer_phone",
                        "delivery_address",
                        "delivery_date",
                        "delivery_time",
                        "items",
                        "total_price"
                    ]
                }
            },
            {
                "name": "track_order_by_phone",
                "description": "–û—Ç—Å–ª–µ–¥–∏—Ç—å –∑–∞–∫–∞–∑—ã –∫–ª–∏–µ–Ω—Ç–∞ –ø–æ –Ω–æ–º–µ—Ä—É —Ç–µ–ª–µ—Ñ–æ–Ω–∞",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "customer_phone": {
                            "type": "string",
                            "description": "–ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∫–ª–∏–µ–Ω—Ç–∞"
                        }
                    },
                    "required": ["customer_phone"]
                }
            },
            {
                "name": "get_working_hours",
                "description": "–ü–æ–ª—É—á–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ —Ä–∞–±–æ—Ç—ã –º–∞–≥–∞–∑–∏–Ω–∞",
                "input_schema": {
                    "type": "object",
                    "properties": {},
                    "required": []
                }
            },
            {
                "name": "get_shop_settings",
                "description": "–ü–æ–ª—É—á–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –º–∞–≥–∞–∑–∏–Ω–µ",
                "input_schema": {
                    "type": "object",
                    "properties": {},
                    "required": []
                }
            }
        ]

    async def execute_tool(
        self,
        tool_name: str,
        tool_input: Dict[str, Any]
    ) -> str:
        """
        Execute a tool call via MCP client with logging.

        Args:
            tool_name: Name of the tool to execute
            tool_input: Tool arguments

        Returns:
            String representation of tool result
        """
        # Add shop_id to all tool calls
        tool_input["shop_id"] = self.shop_id

        # Log tool call
        self.logger.log_message(
            sender="manager",
            message_type="tool_call",
            content=f"Calling {tool_name}",
            metadata={
                "tool_name": tool_name,
                "arguments": tool_input
            }
        )

        start_time = time.time()

        try:
            # Call appropriate MCP method
            if tool_name == "list_products":
                result = await self.mcp_client.list_products(**tool_input)
            elif tool_name == "get_product":
                result = await self.mcp_client.get_product(**tool_input)
            elif tool_name == "create_order":
                # Add telegram_user_id placeholder for testing
                tool_input["telegram_user_id"] = "test_client"
                result = await self.mcp_client.create_order(**tool_input)
            elif tool_name == "track_order_by_phone":
                result = await self.mcp_client.track_order_by_phone(**tool_input)
            elif tool_name == "get_working_hours":
                result = await self.mcp_client.get_working_hours(**tool_input)
            elif tool_name == "get_shop_settings":
                result = await self.mcp_client.get_shop_settings(**tool_input)
            else:
                raise ValueError(f"Unknown tool: {tool_name}")

            latency = (time.time() - start_time) * 1000

            # Log successful tool call
            self.logger.log_tool_call(
                tool_name=tool_name,
                arguments=tool_input,
                result=result,
                latency_ms=latency,
                success=True
            )

            # Log tool result
            self.logger.log_message(
                sender="manager",
                message_type="tool_result",
                content=f"Tool {tool_name} succeeded",
                metadata={
                    "tool_name": tool_name,
                    "result": result
                }
            )

            return str(result)

        except Exception as e:
            latency = (time.time() - start_time) * 1000

            # Log failed tool call
            self.logger.log_tool_call(
                tool_name=tool_name,
                arguments=tool_input,
                latency_ms=latency,
                success=False,
                error=str(e)
            )

            logger.error(f"Tool execution error ({tool_name}): {str(e)}")
            return f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ {tool_name}: {str(e)}"

    async def process_message(self, message: str) -> str:
        """
        Process a message from client and generate response.

        Args:
            message: Client's text message

        Returns:
            Manager's text response
        """
        # Log incoming message
        self.logger.log_message(
            sender="client",
            message_type="text",
            content=message
        )

        # Add user message to history
        self.messages.append({
            "role": "user",
            "content": message
        })

        # Call Claude with function calling and new features
        response = self.client.messages.create(
            model=self.model,
            max_tokens=config.MAX_TOKENS,
            system=self.get_system_prompt(),
            messages=self.messages,
            tools=self.get_tools_schema(),
            extra_headers=config.CLAUDE_EXTRA_HEADERS  # Enable memory, context editing, interleaved thinking
        )

        # Process tool calls if any
        while response.stop_reason == "tool_use":
            # Extract tool calls and content from response
            tool_results = []
            assistant_content = []

            for block in response.content:
                if block.type == "thinking":
                    # Log thinking block (interleaved thinking feature)
                    self.logger.log_message(
                        sender="manager",
                        message_type="thinking",
                        content=block.thinking
                    )
                    assistant_content.append(block)

                elif block.type == "tool_use":
                    # Execute tool
                    tool_result = await self.execute_tool(
                        block.name,
                        block.input
                    )
                    tool_results.append({
                        "type": "tool_result",
                        "tool_use_id": block.id,
                        "content": tool_result
                    })
                    assistant_content.append(block)

                elif block.type == "text":
                    assistant_content.append(block)

            # Add assistant response with tool calls to history
            self.messages.append({
                "role": "assistant",
                "content": assistant_content
            })

            # Add tool results to history
            if tool_results:
                self.messages.append({
                    "role": "user",
                    "content": tool_results
                })

                # Continue conversation with tool results
                response = self.client.messages.create(
                    model=self.model,
                    max_tokens=config.MAX_TOKENS,
                    system=self.get_system_prompt(),
                    messages=self.messages,
                    tools=self.get_tools_schema(),
                    extra_headers=config.CLAUDE_EXTRA_HEADERS
                )

        # Extract final text response
        final_text = ""
        for block in response.content:
            if block.type == "thinking":
                # Log final thinking if any
                self.logger.log_message(
                    sender="manager",
                    message_type="thinking",
                    content=block.thinking
                )
            elif block.type == "text":
                final_text += block.text

        # Log manager's response
        self.logger.log_message(
            sender="manager",
            message_type="text",
            content=final_text
        )

        # Add final response to history
        self.messages.append({
            "role": "assistant",
            "content": final_text
        })

        # Limit conversation history to prevent token overflow
        # Context editing should handle this, but as safety measure
        if len(self.messages) > 30:
            # Keep system context, trim middle
            self.messages = self.messages[:2] + self.messages[-28:]

        return final_text

    async def close(self):
        """Close MCP client connection."""
        await self.mcp_client.close()
